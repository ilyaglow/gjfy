package main

import (
	"bytes"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"flag"
	"fmt"
	"html/template"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"
	"os/signal"
	"path"
	"strings"
	"syscall"
	"time"
)

const (
	myName                = "gjfy"
	defaultHostname       = "localhost"
	listenDefault         = ":9154"
	uApiGet               = "/api/v1/get/"
	uApiNew               = "/api/v1/new"
	uApiCreate            = "/create"
	uGet                  = "/g"
	uInfo                 = "/i"
	uClientShell          = "/gjfy-post"
	uFav                  = "/favicon.ico"
	uLogoSmall            = "/gjfy-logo-small.png"
	uCss                  = "/custom.css"
	uLogo                 = "/logo.png"
	maxData               = 1048576 // 1MB
	defaultValidity       = 7       // days
	expiryCheck           = 30      // minutes
	defaultMaxClicks      = 1
	crtFile               = myName + ".crt"
	keyFile               = myName + ".key"
	TLSDefault            = false
	notifyDefault         = false
	allowAnonymousDefault = false
)

var (
	auth            TokenDB
	css             []byte
	logo            []byte
	updated         = time.Time{}
	fListen         string
	fURLBase        string
	fTLS            bool
	fNotify         bool
	fAllowAnonymous bool
	scheme          = "http://"
	configDir       = "/etc/" + myName
	userMessageView string
)

type viewInfoEntry struct {
	StoreEntryInfo
	UserMessageView string
}

type jsonError struct {
	Error string `json:"error"`
}

func getRealIP(r *http.Request) string {
	xFF := r.Header.Get("X-Forwarded-For")
	xRI := r.Header.Get("X-Real-IP")
	if xFF != "" {
		return xFF
	} else if xRI != "" {
		return xRI
	}
	return "none"
}

func Log(handler http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		realRemoteAddr := getRealIP(r)
		log.Printf("%s (%s) \"%s %s %s\" \"%s\"", r.RemoteAddr, realRemoteAddr, r.Method, r.URL.Path, r.Proto, r.Header.Get("User-Agent"))
		handler.ServeHTTP(w, r)
	})
}

func updateFiles() {
	auth = makeTokenDB(tryReadFile(authFileName))
	if auth == nil {
		log.Println("auth db could not be loaded, please fix and reload")
	}
	css = tryReadFile(cssFileName)
	logo = tryReadFile(logoFileName)
	userMessageView = fileOrConst(userMessageViewFilename, userMessageViewDefaultText)
	updated = time.Now()
}

func getURLBase() string {
	if fURLBase != "" {
		return fURLBase
	}
	sl := strings.Split(fListen, ":")
	port := sl[len(sl)-1]
	return fmt.Sprintf("%s%s:%s", scheme, defaultHostname, port)
}

func main() {
	flag.StringVar(&fListen, "listen", listenDefault, "listen on IP:port")
	flag.StringVar(&fURLBase, "urlbase", "", "base URL (will be generated by default)")
	flag.BoolVar(&fTLS, "tls", TLSDefault, "use TLS connection")
	flag.BoolVar(&fNotify, "notify", notifyDefault, "send email notification when one time link is used")
	flag.BoolVar(&fAllowAnonymous, "allow-anonymous", allowAnonymousDefault, "allow secrets by anonymous users")
	flag.Parse()

	log.Printf("gjfy version %s\n", version)

	store := make(secretStore)
	store.NewEntry("secret", 100, 0, "test@example.org", "test")
	go store.Expiry(time.Minute * expiryCheck)

	updateFiles()

	sighup := make(chan os.Signal, 1)
	signal.Notify(sighup, syscall.SIGHUP)
	go func() {
		for {
			<-sighup
			log.Println("reloading configuration...")
			updateFiles()
		}
	}()

	tIndex := template.New("index")
	tIndex.Parse(htmlMaster)
	tIndex.Parse(htmlIndex)
	tView := template.New("view")
	tView.Parse(htmlMaster)
	tView.Parse(htmlView)
	tViewErr := template.New("viewErr")
	tViewErr.Parse(htmlMaster)
	tViewErr.Parse(htmlViewErr)
	tViewInfo := template.New("viewInfo")
	tViewInfo.Parse(htmlMaster)
	tViewInfo.Parse(htmlViewInfo)
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		type Data struct {
			AllowAnonymous bool
		}
		tIndex.ExecuteTemplate(w, "master", &Data{AllowAnonymous: fAllowAnonymous})
	})

	if fAllowAnonymous {
		http.HandleFunc(uApiCreate, func(w http.ResponseWriter, r *http.Request) {
			err := r.ParseForm()
			if err != nil {
				http.Error(w, err.Error(), http.StatusBadRequest)
				return
			}
			entry := store.NewEntry(r.Form.Get("secret"), 1, 7, "anonymous", "")
			w.Write([]byte(fmt.Sprintf("%s%s?id=%s", getURLBase(), uGet, entry)))
		})
	}

	http.HandleFunc(uApiGet, func(w http.ResponseWriter, r *http.Request) {
		id := r.URL.Path[len(uApiGet):]
		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
		if entry, ok := store.GetEntryInfo(id); !ok {
			w.WriteHeader(http.StatusNotFound)
			log.Printf("entry not found: %s", id)
			if jerr := json.NewEncoder(w).Encode(jsonError{"not found"}); jerr != nil {
				panic(jerr)
			}
		} else {
			store.Click(id, r)
			w.WriteHeader(http.StatusOK)
			if err := json.NewEncoder(w).Encode(entry); err != nil {
				panic(err)
			}
		}
	})

	http.HandleFunc(uApiNew, func(w http.ResponseWriter, r *http.Request) {
		var entry StoreEntry
		body, err := ioutil.ReadAll(io.LimitReader(r.Body, maxData))
		if err != nil {
			panic(err)
		}
		if err := r.Body.Close(); err != nil {
			panic(err)
		}
		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
		if err := json.Unmarshal(body, &entry); err != nil {
			w.WriteHeader(422) // unprocessable entity
			log.Printf("error processing json: %s", err)
			if jerr := json.NewEncoder(w).Encode(jsonError{err.Error()}); jerr != nil {
				panic(jerr)
			}
		} else if !auth.isAuthorized(&entry) {
			w.WriteHeader(http.StatusUnauthorized)
			log.Printf("unauthorized try to make new entry")
			if jerr := json.NewEncoder(w).Encode(jsonError{"unauthorized"}); jerr != nil {
				panic(jerr)
			}
		} else {
			id := store.AddEntry(entry, "")
			newEntry, _ := store.GetEntryInfoHidden(id)
			log.Println("New ID:", id)
			w.WriteHeader(http.StatusCreated)
			if err := json.NewEncoder(w).Encode(newEntry); err != nil {
				panic(err)
			}
		}
	})

	http.HandleFunc(uGet, func(w http.ResponseWriter, r *http.Request) {
		id := r.URL.Query().Get("id")
		if entry, ok := store.GetEntryInfo(id); !ok {
			w.WriteHeader(http.StatusNotFound)
			log.Printf("entry not found: %s", id)
			tViewErr.ExecuteTemplate(w, "master", nil)
		} else {
			store.Click(id, r)
			w.WriteHeader(http.StatusOK)
			viewEntry := viewInfoEntry{entry, userMessageView}
			tView.ExecuteTemplate(w, "master", viewEntry)
		}
	})

	http.HandleFunc(uInfo, func(w http.ResponseWriter, r *http.Request) {
		id := r.URL.Query().Get("id")
		if entry, ok := store.GetEntryInfo(id); !ok {
			w.WriteHeader(http.StatusNotFound)
			tViewErr.ExecuteTemplate(w, "master", nil)
		} else {
			w.WriteHeader(http.StatusOK)
			tViewInfo.ExecuteTemplate(w, "master", entry)
		}
	})

	http.HandleFunc(uFav, func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "image/x-icon")
		w.WriteHeader(http.StatusOK)
		w.Write(favicon)
	})

	http.HandleFunc(uLogoSmall, func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "image/png")
		w.WriteHeader(http.StatusOK)
		w.Write(gjfyLogoSmall)
	})

	http.HandleFunc(uCss, func(w http.ResponseWriter, r *http.Request) {
		http.ServeContent(w, r, cssFileName, updated, bytes.NewReader(css))
	})

	http.HandleFunc(uLogo, func(w http.ResponseWriter, r *http.Request) {
		http.ServeContent(w, r, logoFileName, updated, bytes.NewReader(logo))
	})

	http.HandleFunc(uClientShell, func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/x-sh")
		w.WriteHeader(http.StatusOK)
		ClientShellScript(w, getURLBase()+uApiNew)
	})

	if fNotify {
		log.Println("email notifications enabled")
	}

	if fTLS {
		scheme = "https://"
		cf := tryFile(crtFile)
		if cf == "" {
			log.Fatalf("unable to open %s\n", crtFile)
		}
		kf := tryFile(keyFile)
		if kf == "" {
			log.Fatalf("unable to open %s\n", keyFile)
		}
		log.Printf("using '%s' as URL base\n", getURLBase())
		log.Println("listening on", fListen, "with TLS")
		log.Fatal(http.ListenAndServeTLS(fListen, cf, kf, Log(http.DefaultServeMux)))
	} else {
		log.Printf("using '%s' as URL base\n", getURLBase())
		log.Println("listening on", fListen, "without TLS")
		log.Fatal(http.ListenAndServe(fListen, Log(http.DefaultServeMux)))
	}
}

const (
	hiddenString = "#HIDDEN#"
)

var (
	expFactor = realExpFactor
)

// In-memory representation of a secret.
type StoreEntry struct {
	Secret    string    `json:"secret"`
	MaxClicks int       `json:"max_clicks"`
	Clicks    int       `json:"clicks"`
	DateAdded time.Time `json:"date_added"`
	ValidFor  int       `json:"valid_for"`
	AuthToken string    `json:"auth_token"`
}

// Secret augmented with computed fields.
type StoreEntryInfo struct {
	StoreEntry
	Id        string `json:"id"`
	PathQuery string `json:"path_query"`
	Url       string `json:"url"`
	ApiUrl    string `json:"api_url"`
}

type secretStore map[string]StoreEntry

// hashStruct returns a hash from an arbitrary structure, usable in a URL.
func hashStruct(data interface{}) (hash string) {
	hashBytes := sha256.Sum256([]byte(fmt.Sprintf("%v", data)))
	hash = base64.RawURLEncoding.EncodeToString(hashBytes[:])
	return
}

// AddEntry adds a secret to the store.
func (st secretStore) AddEntry(e StoreEntry, id string) string {
	e.DateAdded = time.Now()
	if id == "" {
		id = hashStruct(e)
	}
	if e.ValidFor == 0 {
		e.ValidFor = defaultValidity
	}
	if e.MaxClicks == 0 {
		e.MaxClicks = defaultMaxClicks
	}
	st[id] = e
	return id
}

// NewEntry adds a new secret to the store. Set id to ""
// to have it auto-generated by hashing the entry.
func (st secretStore) NewEntry(secret string, maxclicks int, validfor int, at string, id string) string {
	return st.AddEntry(StoreEntry{secret, maxclicks, 0, time.Time{}, validfor, at}, id)
}

// GetEntry retrieves a secret from the store.
func (st secretStore) GetEntry(id string) (se StoreEntry, ok bool) {
	se, ok = st[id]
	return
}

// GetEntryInfo wraps GetEntry and adds some computed fields.
func (st secretStore) GetEntryInfo(id string) (si StoreEntryInfo, ok bool) {
	entry, ok := st.GetEntry(id)
	pathQuery := uGet + "?id=" + id
	url := getURLBase() + pathQuery
	apiurl := getURLBase() + uApiGet + id
	return StoreEntryInfo{entry, id, pathQuery, url, apiurl}, ok
}

// GetEntryInfo wraps GetEntry and adds some computed fields. In addition it
// hides the "secret" value.
func (st secretStore) GetEntryInfoHidden(id string) (si StoreEntryInfo, ok bool) {
	si, ok = st.GetEntryInfo(id)
	si.Secret = hiddenString
	return
}

// Click increases the click counter for an entry and sends a notification
func (st secretStore) Click(id string, r *http.Request) {
	var msg string
	entry, ok := st.GetEntry(id)
	if ok {
		// in any case increase number of clicks in our temporary entry
		entry.Clicks += 1
		if entry.Clicks < entry.MaxClicks {
			// max clicks not yet reached, save our modified entry to the store
			st[id] = entry
		} else {
			// max clicks reached, delete entry from store
			delete(st, id)
		}
		msg = fmt.Sprintf(`
Id:          %s
Clicked:     %d time(s)
Clicks left: %d
Request:     %s (%s) %s %s %s
User-Agent:  %s
`,
			id, entry.Clicks, entry.MaxClicks-entry.Clicks,
			r.RemoteAddr, getRealIP(r), r.Method, r.URL.Path, r.Proto,
			r.Header.Get("User-Agent"))
		NotifyMail(entry.AuthToken, msg)
	}
	return
}

// realExpFactor will scale the given int value to a certain amount of time
func realExpFactor(v int) time.Duration {
	return time.Hour * 24 * time.Duration(v)
}

// Expiry checks for expired entries at regular intervals
func (st secretStore) Expiry(interval time.Duration) {
	tck := time.NewTicker(interval)
	log.Printf("checking for expiration every %s\n", interval)
	for {
		now := time.Now()
		for id, e := range st {
			expDate := e.DateAdded
			expDate = expDate.Add(expFactor(e.ValidFor))
			if now.After(expDate) {
				log.Printf("%s expired\n", id)
				delete(st, id)
			}
		}
		<-tck.C
	}
}

var (
	version = "1.1"
)

// fileOrConst works like tryReadFile, except it returns a string
// and, if the file is not accessible, a default string.
func fileOrConst(fn string, def string) string {
	pn := tryReadFile(fn)
	if len(pn) > 0 {
		return string(pn)
	}
	return def
}

// tryReadFile takes a _filename_ and uses tryFile() to find the file and
// eventually return its contents. If the files was not found or is unreadable
// returns an empty byte slice.
func tryReadFile(fn string) []byte {
	pn := tryFile(fn)
	contents, err := ioutil.ReadFile(pn)
	if err == nil {
		return contents
	}
	return []byte{}
}

// tryFile takes a _filename_ as an argument and tries several directories to
// find this file. In the case of success it returns the full path name,
// otherwise it returns the empty string.
func tryFile(fn string) string {
	var dirs []string
	cwd, err := os.Getwd()
	if err == nil {
		dirs = append(dirs, cwd)
	} else {
		log.Println("could not get working directory")
	}
	dirs = append(dirs, configDir)
	for _, dir := range dirs {
		pn := path.Join(dir, fn)
		f, err := os.Open(pn)
		if err == nil {
			log.Printf("found %s in %s\n", fn, dir)
			f.Close()
			return pn
		}
	}
	log.Println("could not find", fn)
	return ""
}

type ClientVars struct {
	DefaultPostURL string
}

const (
	shellClient = `#!/bin/bash

POSTURL="${GJFY_POSTURL:-{{.DefaultPostURL}}}"

which jq >/dev/null 2>&1 || {
    echo "jq utility not found" >&2
    exit 1
}

if [[ $# -lt 2 ]]
then
    echo "usage: $0 <authtoken> <secret>" >&2
    exit 2
fi

if [[ -z "$3" ]]
then
    postdata="{\"auth_token\":\"$1\",\"secret\":\"$2\"}"
else
    postdata="{\"auth_token\":\"$1\",\"secret\":\"$2\",\"max_clicks\":$3}"
fi
curl -s -X POST -d "$postdata" "$POSTURL" | jq -r '.url,.api_url,.error | select (.!=null)'
`
)

func ClientShellScript(out io.Writer, url string) error {
	cv := ClientVars{url}
	tmpl, err := template.New("shellClient").Parse(shellClient)
	if err != nil {
		return err
	}
	err = tmpl.Execute(out, cv)
	if err != nil {
		return err
	}
	return err
}

const (
	authFileName = "auth.db"
)

type AuthToken struct {
	Token string `json:token`
	Email string `json:email`
}

type TokenDB []AuthToken

func makeTokenDB(b []byte) TokenDB {
	var tokens TokenDB
	err := json.Unmarshal(b, &tokens)
	if err != nil {
		log.Println("error reading auth token db:", err)
	}
	for i, entry := range tokens {
		if entry.Token == "" {
			log.Printf("token field empty or missing in entry #%d", i)
			return nil
		}
		if entry.Email == "" {
			log.Printf("email field empty or missing in entry #%d", i)
			return nil
		}
	}
	log.Printf("found %d auth tokens\n", len(tokens))
	return tokens
}

func (db TokenDB) findToken(token string) (email string) {
	for _, i := range db {
		if i.Token == token {
			email = i.Email
			return
		}
	}
	return
}

// isAuthorized tries to find the auth token given in entry.
// It will the change the entry parameter by replacing the auth
// token with the associated email address. This is to have the
// auth token not end up in the secret database.
func (db TokenDB) isAuthorized(entry *StoreEntry) bool {
	email := db.findToken(entry.AuthToken)
	if email == "" {
		return false
	}
	entry.AuthToken = email
	return true
}

const (
	userMessageViewDefaultText = ``
	userMessageViewFilename    = `userMessage.txt`
	htmlMaster                 = `
	{{define "master"}}
	<!DOCTYPE html>
	<html>
	<head>
		<title>gjfy{{block "title" .}}{{end}}</title>
		<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
		<link rel="stylesheet" type="text/css" href="custom.css">
	</head>
	<body>
	<div class="gjfy-container">
    <a href="/"><img src="logo.png" alt="logo" class="gjfy-logo"></a>
	<div id="content">
	{{block "content" .}}{{end}}
	</div>
	{{block "footer" .}}
	{{end}}
	</div>
	</body>
	</html>
	{{end}}
	`
	htmlIndex = `
	{{define "title"}} - one time links{{end}}
	{{define "content"}}
	<div id="main">
	<h1>one time links</h1>
		{{if .AllowAnonymous}}<p>Create a secret below:</p>
		<form method="POST" action="/create" autocomplete="off">
		<div class="form-group" id="create-secret-container">
		<textarea name="secret" class="form-control" rows="20" autofocus required>Enter secret to share</textarea>
		</div>
		<button class="btn create-secret-form-control">Submit</button></form></div>{{end}}
		<br>
		<!--<a href="gjfy-post">Download command line client</a>-->
	</div>
	{{end}}
	`
	htmlView = `
	{{define "title"}} - View Secret{{end}}
	{{define "content"}}
	<div id="main">
	<p>The secret contained in this link is as follows:</p>
	<textarea class="form-control" rows="20" readonly autofocus type="text">{{.Secret}}</textarea>
	</div>
	{{end}}
	{{block "footer" .}}
		<div id="footer">
		<p>This <a href="https://github.com/sstark/gjfy"><img src="gjfy-logo-small.png" alt="gjfy-logo" class="gjfy-footer-logo-small"></a> secret was created by
			<a href="mailto:{{.AuthToken}}">{{.AuthToken}} </a>
		</p>
		</div>
	{{end}}
	`
	htmlViewInfo = `
	{{define "title"}} - View Info{{end}}
	{{define "content"}}
	<h2 id="mainheading">Metadata for {{.Id}}</h2>
	<div id="main">
	<table id="info">
	<tr>
		<th>Id</th>
		<th>MaxClicks</th>
		<th>Clicks</th>
		<th>DateAdded</th>
		<th>AuthToken</th>
	</tr>
	<tr>
		<td><a href="{{.Url}}">{{.Id}}</a></td>
		<td>{{.MaxClicks}}</td>
		<td>{{.Clicks}}</td>
		<td>{{.DateAdded}}</td>
		<td>{{.AuthToken}}</td>
	</tr>
	</table>
	</div>
	{{end}}
	`
	htmlViewErr = `
	{{define "title"}} - Error{{end}}
	{{define "content"}}
	<h2 id="errorheading">Not available</h2>
	<div id="main">
	<p id="errormessage">This ID is not valid anymore. Please request another one from the person who sent you this link.</p>
	</div>
	{{end}}
	{{define "footer"}}
		<div id="footer">
		<p><a href="https://github.com/sstark/gjfy"><img src="gjfy-logo-small.png" alt="gjfy-logo" class="gjfy-footer-logo-small"></a>
		</p>
		</div>
	{{end}}
	`
	cssFileName  = "custom.css"
	logoFileName = "logo.png"
)

var (
	favicon = []byte{0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x10, 0x10, 0x10, 0x0, 0x1,
		0x0, 0x4, 0x0, 0x28, 0x1, 0x0, 0x0, 0x16, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0,
		0x0, 0x10, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x1, 0x0, 0x4, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
		0xff, 0x0, 0x0, 0xfe, 0x7f, 0x0, 0x0, 0xfe, 0x7f, 0x0, 0x0, 0xff, 0xff,
		0x0, 0x0, 0xfe, 0x7f, 0x0, 0x0, 0xfe, 0x7f, 0x0, 0x0, 0xff, 0x3f, 0x0, 0x0,
		0xff, 0x9f, 0x0, 0x0, 0xfd, 0xdf, 0x0, 0x0, 0xfc, 0x9f, 0x0, 0x0, 0xfe,
		0x3f, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff,
		0x0, 0x0}
	gjfyLogoSmall = []byte{0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a,
		0xa, 0x0, 0x0, 0x0, 0xd, 0x49, 0x48, 0x44, 0x52, 0x0, 0x0, 0x0, 0x3f,
		0x0, 0x0, 0x0, 0x2a, 0x8, 0x6, 0x0, 0x0, 0x0, 0x4, 0x44, 0x83, 0xf7,
		0x0, 0x0, 0x0, 0x4, 0x73, 0x42, 0x49, 0x54, 0x8, 0x8, 0x8, 0x8, 0x7c,
		0x8, 0x64, 0x88, 0x0, 0x0, 0x0, 0x9, 0x70, 0x48, 0x59, 0x73, 0x0, 0x0,
		0xb, 0x12, 0x0, 0x0, 0xb, 0x12, 0x1, 0xd2, 0xdd, 0x7e, 0xfc, 0x0, 0x0,
		0x0, 0x1c, 0x74, 0x45, 0x58, 0x74, 0x53, 0x6f, 0x66, 0x74, 0x77, 0x61,
		0x72, 0x65, 0x0, 0x41, 0x64, 0x6f, 0x62, 0x65, 0x20, 0x46, 0x69, 0x72,
		0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x43, 0x53, 0x36, 0xe8, 0xbc,
		0xb2, 0x8c, 0x0, 0x0, 0x0, 0x18, 0x74, 0x45, 0x58, 0x74, 0x43, 0x72,
		0x65, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x54, 0x69, 0x6d, 0x65, 0x0,
		0x32, 0x37, 0x2e, 0x30, 0x31, 0x2e, 0x32, 0x30, 0x31, 0x37, 0x94, 0xa1,
		0x3d, 0x17, 0x0, 0x0, 0x4, 0xa8, 0x49, 0x44, 0x41, 0x54, 0x68, 0x81,
		0xcd, 0x9a, 0xc1, 0x75, 0xe3, 0x46, 0xc, 0x86, 0xbf, 0xd5, 0xdb, 0xbb,
		0xdc, 0x81, 0x95, 0xa, 0xac, 0xe, 0xa2, 0xad, 0x60, 0x95, 0xa, 0x96,
		0x39, 0xe1, 0xb8, 0xde, 0xa, 0xa2, 0xad, 0x20, 0xda, 0x23, 0x4e, 0x4b,
		0x55, 0x10, 0xb9, 0x82, 0xd0, 0x15, 0x44, 0xae, 0x20, 0x52, 0x7, 0x56,
		0x7, 0x39, 0xc, 0x28, 0xd3, 0x23, 0x70, 0x38, 0xa4, 0x68, 0xc5, 0xff,
		0x7b, 0x7e, 0x16, 0x87, 0x98, 0xe1, 0x60, 0x8, 0x60, 0x7e, 0x60, 0xf8,
		0x81, 0x2b, 0x41, 0x55, 0x6f, 0x80, 0x2d, 0xf0, 0x2b, 0x70, 0x0, 0xa,
		0x11, 0xa9, 0x12, 0xf2, 0x5, 0xb0, 0x4, 0x16, 0xc0, 0x14, 0x38, 0x2,
		0xa5, 0x88, 0xdc, 0x8f, 0x35, 0xa7, 0x8f, 0x63, 0xd, 0x94, 0x81, 0x82,
		0xa0, 0x38, 0xc0, 0x2d, 0x50, 0x2, 0xb3, 0x58, 0x28, 0x5a, 0xa4, 0x26,
		0xa6, 0xc0, 0x57, 0x55, 0xad, 0x44, 0x64, 0x3b, 0xc6, 0x84, 0x26, 0x63,
		0xc, 0x92, 0x89, 0x9b, 0xe8, 0xfa, 0xb6, 0x45, 0xae, 0xe4, 0x5c, 0xf1,
		0xd4, 0x38, 0x83, 0x71, 0x4d, 0xe5, 0x3b, 0xa1, 0xaa, 0xb, 0xe0, 0x73,
		0x42, 0xe4, 0x8, 0x54, 0x63, 0x3d, 0xef, 0x9a, 0x66, 0x9f, 0x83, 0xa5,
		0xd3, 0x76, 0x24, 0xb8, 0xc1, 0x9e, 0xe0, 0xf3, 0xfb, 0xb1, 0x1e, 0xf6,
		0xde, 0x94, 0x9f, 0x3b, 0x6d, 0xb, 0x11, 0xd9, 0xbd, 0xc5, 0xc3, 0xae,
		0x69, 0xf6, 0xfb, 0xe8, 0xfa, 0xd1, 0x91, 0x89, 0xfd, 0xf9, 0xf1, 0xad,
		0x14, 0x87, 0x2b, 0x2a, 0x2f, 0x22, 0x25, 0xf0, 0x9d, 0xa0, 0xf4, 0x86,
		0x10, 0xfd, 0x63, 0xdc, 0x5d, 0x6b, 0x3e, 0x90, 0x61, 0xf6, 0xaa, 0x3a,
		0x27, 0xf8, 0xe2, 0x9c, 0x97, 0x37, 0xb3, 0x27, 0x4, 0x9e, 0xad, 0x88,
		0x3c, 0x47, 0xf2, 0x33, 0x60, 0xe6, 0xed, 0xe1, 0x22, 0xb2, 0xba, 0x64,
		0xb2, 0xce, 0xdc, 0x6e, 0xe2, 0xe7, 0xf7, 0xe9, 0xf3, 0x21, 0x21, 0x54,
		0x0, 0x2b, 0xda, 0xb7, 0x24, 0x8, 0xc1, 0x68, 0xd, 0xac, 0x45, 0xe4,
		0x59, 0x55, 0xef, 0x81, 0x3f, 0xed, 0xde, 0x13, 0xc1, 0x5f, 0x4f, 0x93,
		0xb3, 0x85, 0x59, 0x0, 0xbb, 0xa6, 0x39, 0x5b, 0x7b, 0x49, 0x7a, 0x8b,
		0xfb, 0x51, 0x13, 0x1c, 0x93, 0xdf, 0x12, 0x2c, 0xe5, 0x48, 0x46, 0x5c,
		0x30, 0xfe, 0x50, 0x35, 0xfa, 0xdc, 0x9f, 0x99, 0xbd, 0xaa, 0xce, 0x54,
		0xb5, 0x2, 0x7e, 0x92, 0x56, 0x1c, 0x2, 0xf1, 0xf8, 0x3, 0xa8, 0xcc,
		0x42, 0x56, 0x8d, 0x7b, 0x77, 0x34, 0x2, 0x98, 0xdd, 0xdf, 0xd9, 0xb8,
		0xff, 0xa8, 0xea, 0xba, 0x21, 0xbb, 0x26, 0xad, 0x38, 0x4, 0x82, 0x53,
		0xef, 0x6, 0x2b, 0x5e, 0x5c, 0x64, 0x4a, 0x58, 0xb8, 0x2e, 0x14, 0x51,
		0x9f, 0xf5, 0x2b, 0xe5, 0x1b, 0x13, 0xec, 0x9a, 0x48, 0x8c, 0x3b, 0xc2,
		0xaa, 0x4e, 0x13, 0x32, 0xcb, 0xe8, 0xfe, 0xd7, 0xc6, 0xef, 0x5c, 0xe2,
		0x52, 0x2f, 0x66, 0x2c, 0x7f, 0x67, 0xd6, 0x90, 0x42, 0x4c, 0x8b, 0xa7,
		0x27, 0xe5, 0x4d, 0xf1, 0x8a, 0xb4, 0x2, 0x8f, 0x4, 0x73, 0xf6, 0x90,
		0xea, 0xd7, 0x85, 0x2a, 0x53, 0xae, 0xb4, 0xff, 0x1e, 0xbd, 0x6d, 0xe5,
		0xfc, 0xa6, 0x5b, 0x6c, 0xc5, 0xf, 0xcd, 0x80, 0x57, 0xe2, 0x2b, 0xb0,
		0x21, 0xf8, 0xf4, 0x2b, 0x9f, 0xb2, 0x98, 0x70, 0xcf, 0x8, 0x11, 0x5a,
		0x44, 0x56, 0xaa, 0xfa, 0xcc, 0x4b, 0xbc, 0xa8, 0x71, 0xe0, 0x45, 0xe1,
		0xaa, 0x41, 0x70, 0xb6, 0x4, 0xf7, 0x69, 0x62, 0x49, 0xfb, 0x2, 0x14,
		0x4e, 0xdb, 0x76, 0x2, 0xa0, 0xaa, 0x2b, 0xce, 0x95, 0x38, 0x2, 0xbf,
		0x89, 0x48, 0xe1, 0x5, 0x13, 0x11, 0x29, 0x45, 0x64, 0x4e, 0x58, 0x9c,
		0x8b, 0x21, 0x22, 0x6b, 0xa7, 0x79, 0x2f, 0x22, 0x2b, 0xfb, 0xab, 0x1a,
		0xb2, 0xcf, 0xc0, 0x43, 0x24, 0x7b, 0x6b, 0x6f, 0xd8, 0x43, 0xcc, 0x1c,
		0x8f, 0x22, 0x52, 0xd6, 0x66, 0xef, 0xad, 0xd8, 0x32, 0x27, 0x7b, 0x12,
		0x91, 0xc2, 0x99, 0xc8, 0x35, 0x50, 0x3a, 0x6d, 0x45, 0xdc, 0xd0, 0x62,
		0xf2, 0x5b, 0x80, 0x89, 0x99, 0x6f, 0x6c, 0xee, 0x9b, 0x54, 0xae, 0xed,
		0x60, 0xb4, 0x1c, 0x3b, 0x17, 0xf6, 0x62, 0x8e, 0x51, 0xb3, 0x97, 0x1b,
		0x14, 0x4e, 0xdb, 0x1a, 0x2, 0xc3, 0x5b, 0x38, 0x37, 0x57, 0x3d, 0x27,
		0xb2, 0x67, 0x24, 0xf3, 0xef, 0x89, 0xd8, 0x32, 0x3d, 0xd3, 0x8f, 0x17,
		0xe4, 0x50, 0xbb, 0xf1, 0x84, 0xf3, 0x82, 0xc2, 0x61, 0x60, 0xe6, 0x54,
		0xd, 0xe8, 0x73, 0x29, 0xbc, 0x38, 0x71, 0xb2, 0xc2, 0x16, 0x93, 0x3f,
		0xf5, 0xf1, 0xb8, 0xfd, 0x7e, 0xe0, 0x44, 0x86, 0xf6, 0x1b, 0xc, 0x7b,
		0x83, 0x87, 0xa8, 0xb9, 0xf9, 0xa6, 0xb, 0xa7, 0xdb, 0xc9, 0x5a, 0xde,
		0x55, 0x31, 0x63, 0x20, 0xca, 0xe8, 0x7a, 0xda, 0x60, 0x82, 0xb1, 0xc9,
		0x3f, 0x34, 0xad, 0xda, 0x53, 0xbe, 0x2f, 0xbb, 0xab, 0xb1, 0x18, 0xd8,
		0xef, 0x52, 0x94, 0x4e, 0xdb, 0x32, 0x15, 0xe5, 0x6b, 0x4c, 0x70, 0x7c,
		0xd5, 0x76, 0x80, 0xbe, 0x18, 0xd2, 0xe7, 0x62, 0xd8, 0x9b, 0x8c, 0x59,
		0xa7, 0x47, 0x78, 0x8e, 0x96, 0x56, 0x9f, 0x30, 0xc1, 0x5f, 0xb9, 0x95,
		0x65, 0x41, 0x59, 0xb0, 0xc5, 0xea, 0x4a, 0x82, 0xde, 0x12, 0x71, 0xe0,
		0x9b, 0x2, 0x5f, 0xa2, 0xb6, 0x33, 0xce, 0x32, 0xb1, 0x95, 0x8b, 0xab,
		0x2a, 0xb7, 0xce, 0x80, 0x2e, 0xcc, 0xbc, 0xb2, 0x64, 0xdf, 0x10, 0x39,
		0xa5, 0xec, 0x32, 0x6e, 0x48, 0x31, 0xbc, 0x2f, 0xaa, 0xba, 0x4b, 0x65,
		0x4b, 0x16, 0x58, 0x2a, 0x2e, 0x4b, 0x6a, 0x2e, 0x46, 0xb, 0xdd, 0x6d,
		0xe2, 0xe0, 0x91, 0xb6, 0x8f, 0xd6, 0x79, 0xa7, 0xaa, 0xdf, 0x9, 0xb9,
		0x79, 0x13, 0x77, 0xc0, 0xbf, 0xaa, 0xfa, 0x40, 0x48, 0x75, 0x2b, 0x42,
		0x3a, 0x39, 0x27, 0xf8, 0xf8, 0xff, 0x69, 0xea, 0x31, 0x4a, 0xda, 0xcb,
		0xde, 0xa5, 0xd7, 0x78, 0x8a, 0xf6, 0x56, 0x62, 0x6a, 0x63, 0x69, 0x9f,
		0x9, 0xb, 0xf3, 0x37, 0xf0, 0x97, 0xfd, 0x7e, 0x4f, 0x8a, 0xb7, 0xd1,
		0xdd, 0x1a, 0xa5, 0xd7, 0xf8, 0x6a, 0xab, 0xb3, 0x24, 0xe5, 0xc7, 0xc0,
		0xe7, 0xb7, 0xe5, 0xf9, 0xd7, 0x84, 0xe7, 0xfb, 0x8f, 0x6d, 0x8c, 0xf5,
		0x6c, 0x9f, 0xb7, 0x3a, 0xd9, 0x27, 0xce, 0x99, 0x53, 0xa, 0x1b, 0x7a,
		0xe6, 0x3, 0x2d, 0x88, 0x3, 0x6f, 0xaf, 0xe2, 0x24, 0x3e, 0xc5, 0x2e,
		0xdb, 0x84, 0x5d, 0x86, 0x27, 0x22, 0x95, 0x88, 0xcc, 0x80, 0xdf, 0x49,
		0x7, 0x92, 0x7, 0xe0, 0x93, 0x59, 0x4c, 0x5b, 0x2e, 0xdd, 0x7, 0xcd,
		0x5d, 0xe3, 0x48, 0xff, 0x5, 0x3d, 0xcb, 0xdb, 0x49, 0xec, 0x4, 0xc9,
		0xd2, 0xb5, 0x91, 0x82, 0x12, 0x4e, 0x5b, 0x5a, 0xbd, 0xf7, 0x3f, 0x3b,
		0x5, 0x8e, 0x59, 0x8f, 0x49, 0xb6, 0x3d, 0x6f, 0xab, 0xaa, 0xbf, 0xd8,
		0x58, 0xbb, 0x3e, 0x65, 0x69, 0xdb, 0x95, 0xe2, 0x80, 0x77, 0x56, 0x5a,
		0x6f, 0x22, 0xfb, 0xb8, 0x2a, 0xe3, 0xe4, 0x64, 0xe1, 0xb4, 0xf5, 0x3e,
		0x6d, 0x31, 0xff, 0xdc, 0xf7, 0xed, 0x47, 0x47, 0x12, 0xe3, 0x61, 0x94,
		0xc4, 0xa6, 0x85, 0xe1, 0x3d, 0xf5, 0x3d, 0x50, 0xb8, 0x10, 0x45, 0x74,
		0x7d, 0xe8, 0xaa, 0x44, 0x5d, 0xac, 0x7c, 0x82, 0xe1, 0x95, 0xd1, 0xf5,
		0x68, 0xe7, 0xea, 0xce, 0x1c, 0x96, 0x74, 0x24, 0x31, 0x1e, 0x2e, 0x52,
		0x3e, 0xc1, 0xf0, 0x8e, 0x9c, 0x2b, 0xef, 0x95, 0x98, 0xc6, 0x82, 0x37,
		0x76, 0x27, 0xe5, 0xce, 0xf6, 0xf9, 0x46, 0xc0, 0x9b, 0xd9, 0xdf, 0x92,
		0xf6, 0xb2, 0xf5, 0xca, 0x8e, 0xaf, 0xe6, 0x26, 0x7b, 0xcf, 0xf9, 0x9b,
		0xf1, 0x4e, 0x69, 0x7b, 0xc3, 0x12, 0xb0, 0x38, 0x89, 0x79, 0xca, 0xa9,
		0x46, 0x65, 0x29, 0x6f, 0x3e, 0x1d, 0xd7, 0xc9, 0xdb, 0xb0, 0x11, 0x91,
		0xb5, 0xaa, 0xee, 0x48, 0xd7, 0xf4, 0x47, 0xf9, 0xae, 0x86, 0x44, 0x81,
		0xb2, 0xb, 0xb9, 0x66, 0x9f, 0x5b, 0x9d, 0xdd, 0x88, 0x48, 0x61, 0x9f,
		0x97, 0xa4, 0x14, 0xf7, 0xdc, 0x62, 0x28, 0x3c, 0x93, 0xcf, 0x5a, 0xd8,
		0x5c, 0xe5, 0xbb, 0xa2, 0xf6, 0x11, 0xf8, 0x66, 0x64, 0xa7, 0xb, 0xf5,
		0xa9, 0xea, 0x58, 0x3b, 0x41, 0x1c, 0x48, 0x37, 0xb9, 0x63, 0xe7, 0x2a,
		0x5f, 0xb6, 0xb4, 0x3f, 0x2, 0xdf, 0x8, 0xe7, 0xf1, 0x27, 0x53, 0xb3,
		0xf4, 0xd1, 0xf3, 0xe9, 0xd, 0x30, 0x1f, 0xf9, 0x6b, 0x8b, 0x15, 0x2f,
		0x9, 0x4d, 0x7d, 0x64, 0x9e, 0x85, 0xd6, 0xf3, 0xf9, 0x18, 0xf5, 0x47,
		0x7, 0x76, 0xe9, 0x31, 0x3c, 0xaf, 0xcf, 0x89, 0x15, 0xf6, 0x3c, 0x4,
		0xe9, 0x5, 0xb, 0x7a, 0x73, 0x7a, 0xb2, 0xc2, 0xff, 0x0, 0x1c, 0xc8,
		0xaf, 0xaa, 0xbd, 0x1, 0xf1, 0x94, 0x0, 0x0, 0x0, 0x0, 0x49, 0x45,
		0x4e, 0x44, 0xae, 0x42, 0x60, 0x82}
)

func NotifyMail(to, msg string) {
	if fNotify {
		go SendMail(to, "GJFY notice", msg)
	}
}

func SendMail(to, subject, msg string) {
	sendmail := exec.Command("mail", "-s", subject, to)
	stdin, err := sendmail.StdinPipe()
	if err != nil {
		log.Println(err)
		return
	}
	stdout, err := sendmail.StdoutPipe()
	if err != nil {
		log.Println(err)
		return
	}
	sendmail.Start()
	stdin.Write([]byte(msg))
	stdin.Write([]byte("\n"))
	stdin.Close()
	ioutil.ReadAll(stdout)
	sendmail.Wait()
	log.Printf("sending notification to %s done.\n", to)
}
